From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrHua269 <novau233@163.com>
Date: Sat, 13 Apr 2024 12:39:47 +0000
Subject: [PATCH] Base Dirty Patches


diff --git a/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java b/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
index 0ce825d7af2a1dbeac5c22640534ee1901edce20..8997c278b3509f6cb8ec52f31a4a08e6e6a2ca70 100644
--- a/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
+++ b/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
@@ -3,8 +3,10 @@ package ca.spottedleaf.concurrentutil.scheduler;
 import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
 import ca.spottedleaf.concurrentutil.util.TimeUtil;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
 import io.papermc.paper.util.TraceUtil;
 import io.papermc.paper.util.set.LinkedSortedSet;
+import me.earthme.lightingluminol.tickcontroller.RegionTickHolder;
 import org.slf4j.Logger;
 import java.lang.invoke.VarHandle;
 import java.util.BitSet;
@@ -490,11 +492,22 @@ public class SchedulerThreadPool {
                     return;
                 }
 
+                //Molia start - For data pack command
+                if (!RegionTickHolder.INSTANCE.shouldRunNextTick(((TickRegionScheduler.TickThreadRunner) this.thread))){
+                    RegionTickHolder.INSTANCE.onRegionRunnerIdle();//Molia - For data pack command
+                    while (!RegionTickHolder.INSTANCE.shouldRunNextTick((TickRegionScheduler.TickThreadRunner) this.thread)){
+                        LockSupport.parkNanos("IDLE",1_000_000);
+                    }
+                    RegionTickHolder.INSTANCE.onRegionBreakOutIdle(); //Molia - For data pack command
+                }
+                //Molia end
+
                 switch (startStateType) {
                     case STATE_IDLE: {
                         while (this.state.state == STATE_IDLE) {
                             LockSupport.park();
                             if (this.scheduler.halted) {
+                                RegionTickHolder.INSTANCE.onRegionRunnerDestroyed(((TickRegionScheduler.TickThreadRunner) this.thread)); //Molia - For data pack command
                                 return;
                             }
                         }
@@ -513,6 +526,7 @@ public class SchedulerThreadPool {
                             }
                             LockSupport.parkNanos(startState, diff);
                             if (this.scheduler.halted) {
+                                RegionTickHolder.INSTANCE.onRegionRunnerDestroyed(((TickRegionScheduler.TickThreadRunner) this.thread)); //Molia - For data pack command
                                 return;
                             }
                         }
@@ -521,11 +535,12 @@ public class SchedulerThreadPool {
                             continue main_state_loop;
                         }
 
+                        RegionTickHolder.INSTANCE.onRegionRunnerStartTicking(); //Molia - For data pack command
                         // TODO exception handling
                         final boolean reschedule = startStateTask.runTick();
 
                         this.returnTask(startStateTask, reschedule);
-
+                        RegionTickHolder.INSTANCE.onRegionRunnerFinishedCurrentTick(); //Molia - For data pack command
                         continue main_state_loop;
                     }
 
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java b/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java
index 190c5f0b02a3d99054704ae1afbffb3498ddffe1..8106114c49e4589a70bf00430a83a132a049e2db 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/ReferenceList.java
@@ -20,15 +20,15 @@ public final class ReferenceList<E> implements Iterable<E> {
     protected Object[] references = EMPTY_LIST;
     protected int count;
 
-    public int size() {
+    public synchronized int size() {
         return this.count;
     }
 
-    public boolean contains(final E obj) {
+    public synchronized boolean contains(final E obj) {
         return this.referenceToIndex.containsKey(obj);
     }
 
-    public boolean remove(final E obj) {
+    public synchronized boolean remove(final E obj) {
         final int index = this.referenceToIndex.removeInt(obj);
         if (index == Integer.MIN_VALUE) {
             return false;
@@ -47,7 +47,7 @@ public final class ReferenceList<E> implements Iterable<E> {
         return true;
     }
 
-    public boolean add(final E obj) {
+    public synchronized boolean add(final E obj) {
         final int count = this.count;
         final int currIndex = this.referenceToIndex.putIfAbsent(obj, count);
 
@@ -68,22 +68,22 @@ public final class ReferenceList<E> implements Iterable<E> {
         return true;
     }
 
-    public E getChecked(final int index) {
+    public synchronized E getChecked(final int index) {
         if (index < 0 || index >= this.count) {
             throw new IndexOutOfBoundsException("Index: " + index + " is out of bounds, size: " + this.count);
         }
         return (E)this.references[index];
     }
 
-    public E getUnchecked(final int index) {
+    public synchronized E getUnchecked(final int index) {
         return (E)this.references[index];
     }
 
-    public Object[] getRawData() {
+    public synchronized Object[] getRawData() {
         return this.references;
     }
 
-    public void clear() {
+    public synchronized void clear() {
         this.referenceToIndex.clear();
         Arrays.fill(this.references, 0, this.count, null);
         this.count = 0;
@@ -96,12 +96,12 @@ public final class ReferenceList<E> implements Iterable<E> {
             private int current;
 
             @Override
-            public boolean hasNext() {
+            public synchronized boolean hasNext() {
                 return this.current < ReferenceList.this.count;
             }
 
             @Override
-            public E next() {
+            public synchronized E next() {
                 if (this.current >= ReferenceList.this.count) {
                     throw new NoSuchElementException();
                 }
@@ -109,7 +109,7 @@ public final class ReferenceList<E> implements Iterable<E> {
             }
 
             @Override
-            public void remove() {
+            public synchronized void remove() {
                 final E lastRet = this.lastRet;
 
                 if (lastRet == null) {
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index 0d8b2a4127e8c8e4970d220b8a2240490da6e7df..5eeda811ca67731b802f8d5b52cb76930a7802a1 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -35,6 +35,7 @@ import net.minecraft.server.level.TicketType;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.Unit;
 import net.minecraft.world.level.ChunkPos;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.bukkit.plugin.Plugin;
 import org.slf4j.Logger;
 import java.io.IOException;
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
index 92f37abe3eb7ad85fd60d3c80acf77dc575b26ea..ad0c294054fa1900372c5cfbacc7a6ce64d8ae55 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -9,6 +9,7 @@ import com.mojang.logging.LogUtils;
 import io.papermc.paper.chunk.system.io.RegionFileIOThread;
 import io.papermc.paper.chunk.system.scheduling.queue.RadiusAwarePrioritisedExecutor;
 import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.threadedregions.RegionizedServer;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
 import java.util.function.BooleanSupplier;
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
index 6369b13e1fcdbdb25dd9d6e4d3bffdedbee4f739..740d7994a76e73332fb8b4accf388a550e0cf6ce 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
@@ -26,7 +26,7 @@ class PaperPluginProviderFactory implements PluginTypeFactory<PaperPluginParent,
     public PaperPluginParent build(JarFile file, PaperPluginMeta configuration, Path source) {
         // Folia start - block plugins not marked as supported
         if (!configuration.isFoliaSupported()) {
-            throw new RuntimeException("Could not load plugin '" + configuration.getDisplayName() + "' as it is not marked as supporting Folia!");
+         //   throw new RuntimeException("Could not load plugin '" + configuration.getDisplayName() + "' as it is not marked as supporting Folia!");
         }
         // Folia end - block plugins not marked as supported
         Logger jul = PaperPluginLogger.getLogger(configuration);
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
index bf1856316aa45d2de061e6f4268dd9c63deb1ced..1b116b671fea60013d4f1f9c6adbed044d973dca 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
@@ -19,7 +19,7 @@ class SpigotPluginProviderFactory implements PluginTypeFactory<SpigotPluginProvi
     public SpigotPluginProvider build(JarFile file, PluginDescriptionFile configuration, Path source) throws InvalidDescriptionException {
         // Folia start - block plugins not marked as supported
         if (!configuration.isFoliaSupported()) {
-            throw new RuntimeException("Could not load plugin '" + configuration.getDisplayName() + "' as it is not marked as supporting Folia!");
+           // throw new RuntimeException("Could not load plugin '" + configuration.getDisplayName() + "' as it is not marked as supporting Folia!");
         }
         // Folia end - block plugins not marked as supported
         // Copied from SimplePluginManager#loadPlugins
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
index 1f48ada99d6d24880f9bda1cd05d41a4562e42f5..4a0ac6acf90f24939656d4a68cef61fa95d7b0c8 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
@@ -4,6 +4,8 @@ import ca.spottedleaf.concurrentutil.util.Validate;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+
 import javax.annotation.Nullable;
 import java.util.function.Supplier;
 
@@ -152,6 +154,7 @@ public final class RegionizedData<T> {
             throw new IllegalStateException("World check failed: expected world: " + this.world.getWorld().getKey() + ", region world: " + region.getData().world.getWorld().getKey());
         }
 
+
         return region.getData().getOrCreateRegionizedData(this);
     }
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
index 168ed2c21aed6a10f3aca259880b1b8bdbf98b78..fc54dd2fe77543dff5c7299499a296e54c7591fa 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -19,6 +19,7 @@ import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.world.level.GameRules;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.slf4j.Logger;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -62,7 +63,7 @@ public final class RegionizedServer {
         new RegionizedServerInitEvent().callEvent();
 
         // now we can schedule
-        this.tickHandle.setInitialStart(System.nanoTime() + TickRegionScheduler.TIME_BETWEEN_TICKS);
+        this.tickHandle.setInitialStart(System.nanoTime() + TickRegionScheduler.NANOS_PER_TICK_PER_THREAD.getValue());
         TickRegions.getScheduler().scheduleRegion(this.tickHandle);
         TickRegions.getScheduler().init();
     }
@@ -102,7 +103,7 @@ public final class RegionizedServer {
 
     public static void ensureGlobalTickThread(final String reason) {
         if (!isGlobalTickThread()) {
-            throw new IllegalStateException(reason);
+           //throw new IllegalStateException(reason);
         }
     }
 
@@ -293,6 +294,9 @@ public final class RegionizedServer {
         // scheduler
         ((FoliaGlobalRegionScheduler)Bukkit.getGlobalRegionScheduler()).tick();
 
+        //Bukkit scheduler
+        ((CraftScheduler) Bukkit.getScheduler()).mainThreadHeartbeat((int)this.tickCount);
+
         // commands
         ((DedicatedServer)MinecraftServer.getServer()).handleConsoleInputs();
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
index e91df1496889b15041a297f243d7cfe7c78f1f6c..7b5ccf9576a0d4a67a56b9c6976614c9060a4594 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -3,6 +3,9 @@ package io.papermc.paper.threadedregions;
 import com.destroystokyo.paper.util.maplist.ReferenceList;
 import com.destroystokyo.paper.util.misc.PlayerAreaMap;
 import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.chunk.system.scheduling.ChunkHolderManager;
 import io.papermc.paper.util.CoordinateUtils;
@@ -12,7 +15,9 @@ import io.papermc.paper.util.player.NearbyPlayers;
 import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceMap;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ObjectLists;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
@@ -91,10 +96,10 @@ public final class RegionizedWorldData {
             for (final Entity entity : from.toProcessTrackingUnloading) {
                 into.toProcessTrackingUnloading.add(entity);
             }
-            for (final Iterator<Entity> iterator = from.entityTickList.unsafeIterator(); iterator.hasNext();) {
+            for (final Iterator<Entity> iterator = from.entityTickList.iterator(); iterator.hasNext();) {
                 into.entityTickList.add(iterator.next());
             }
-            for (final Iterator<Mob> iterator = from.navigatingMobs.unsafeIterator(); iterator.hasNext();) {
+            for (final Iterator<Mob> iterator = from.navigatingMobs.iterator(); iterator.hasNext();) {
                 into.navigatingMobs.add(iterator.next());
             }
             // block ticking
@@ -312,7 +317,7 @@ public final class RegionizedWorldData {
     private RegionizedServer.WorldLevelData tickData;
 
     // connections
-    public final List<Connection> connections = new ArrayList<>();
+    public final List<Connection> connections = ObjectLists.synchronize(new ObjectArrayList<>());
 
     // misc. fields
     private boolean isHandlingTick;
@@ -326,12 +331,12 @@ public final class RegionizedWorldData {
     }
 
     // entities
-    private final List<ServerPlayer> localPlayers = new ArrayList<>();
+    private final List<ServerPlayer> localPlayers = Lists.newCopyOnWriteArrayList();
     private final NearbyPlayers nearbyPlayers;
     private final ReferenceList<Entity> allEntities = new ReferenceList<>();
     private final ReferenceList<Entity> loadedEntities = new ReferenceList<>();
     private final ReferenceList<Entity> toProcessTrackingUnloading = new ReferenceList<>();
-    private final IteratorSafeOrderedReferenceSet<Entity> entityTickList = new IteratorSafeOrderedReferenceSet<>();
+    private final IteratorSafeOrderedReferenceSet<Entity> entityTickList = new IteratorSafeOrderedReferenceSet<>();//Sets.newConcurrentHashSet();//ObjectSets.synchronize(new ObjectLinkedOpenHashSet<>());
     private final IteratorSafeOrderedReferenceSet<Mob> navigatingMobs = new IteratorSafeOrderedReferenceSet<>();
 
     // block ticking
@@ -340,8 +345,8 @@ public final class RegionizedWorldData {
     private final LevelTicks<Fluid> fluidLevelTicks;
 
     // tile entity ticking
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = new ArrayList<>();
-    private final List<TickingBlockEntity> blockEntityTickers = new ArrayList<>();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = Collections.synchronizedList(new ArrayList<>());
+    private final List<TickingBlockEntity> blockEntityTickers = Collections.synchronizedList(new ArrayList<>());
     private boolean tickingBlockEntities;
 
     // time
@@ -378,8 +383,8 @@ public final class RegionizedWorldData {
     public boolean preventPoiUpdated = false; // CraftBukkit - SPIGOT-5710
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public final Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public final Map<BlockPos, CraftBlockState> capturedBlockStates = Maps.newConcurrentMap(); // Paper
+    public final Map<BlockPos, BlockEntity> capturedTileEntities = Maps.newConcurrentMap(); // Paper
     public List<ItemEntity> captureDrops;
     // Paper start
     public int wakeupInactiveRemainingAnimals;
@@ -489,7 +494,7 @@ public final class RegionizedWorldData {
         this.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
         this.skipHopperEvents = this.world.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
         // always subtract from server init so that the tick starts at zero, allowing us to cast to int without much worry
-        this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / TickRegionScheduler.TIME_BETWEEN_TICKS;
+        this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / TickRegionScheduler.NANOS_PER_TICK_PER_THREAD.getValue();
     }
 
     public NearbyPlayers getNearbyPlayers() {
@@ -594,11 +599,8 @@ public final class RegionizedWorldData {
     }
 
     public void addEntityTickingEntity(final Entity entity) {
-        if (!TickThread.isTickThreadFor(entity)) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
-        }
         this.entityTickList.add(entity);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(entity);
     }
 
     public boolean hasEntityTickingEntity(final Entity entity) {
@@ -606,11 +608,8 @@ public final class RegionizedWorldData {
     }
 
     public void removeEntityTickingEntity(final Entity entity) {
-        if (!TickThread.isTickThreadFor(entity)) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
-        }
         this.entityTickList.remove(entity);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(entity);
     }
 
     public void forEachTickingEntity(final Consumer<Entity> action) {
@@ -625,15 +624,12 @@ public final class RegionizedWorldData {
     }
 
     public void addEntity(final Entity entity) {
-        if (!TickThread.isTickThreadFor(this.world, entity.chunkPosition())) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
-        }
         if (this.allEntities.add(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
                 this.nearbyPlayers.addPlayer(player);
             }
-            TickRegions.RegionStats.updateCurrentRegion();
+            TickRegions.RegionStats.updateCurrentRegion(entity);
         }
     }
 
@@ -642,34 +638,25 @@ public final class RegionizedWorldData {
     }
 
     public void removeEntity(final Entity entity) {
-        if (!TickThread.isTickThreadFor(entity)) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
-        }
         if (this.allEntities.remove(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
                 this.nearbyPlayers.removePlayer(player);
             }
-            TickRegions.RegionStats.updateCurrentRegion();
+            TickRegions.RegionStats.updateCurrentRegion(entity);
         }
     }
 
     public void addNavigatingMob(final Mob mob) {
-        if (!TickThread.isTickThreadFor(mob)) {
-            throw new IllegalArgumentException("Entity " + mob + " is not under this region's control");
-        }
         this.navigatingMobs.add(mob);
     }
 
     public void removeNavigatingMob(final Mob mob) {
-        if (!TickThread.isTickThreadFor(mob)) {
-            throw new IllegalArgumentException("Entity " + mob + " is not under this region's control");
-        }
         this.navigatingMobs.remove(mob);
     }
 
-    public Iterator<Mob> getNavigatingMobs() {
-        return this.navigatingMobs.unsafeIterator();
+    public IteratorSafeOrderedReferenceSet<Mob> getNavigatingMobs() {
+        return this.navigatingMobs;
     }
 
     // block ticking hooks
@@ -742,12 +729,12 @@ public final class RegionizedWorldData {
     // ticking chunks
     public void addEntityTickingChunk(final LevelChunk levelChunk) {
         this.entityTickingChunks.add(levelChunk);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(levelChunk);
     }
 
     public void removeEntityTickingChunk(final LevelChunk levelChunk) {
         this.entityTickingChunks.remove(levelChunk);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(levelChunk);
     }
 
     public IteratorSafeOrderedReferenceSet<LevelChunk> getEntityTickingChunks() {
@@ -770,12 +757,12 @@ public final class RegionizedWorldData {
 
     public void addChunk(final LevelChunk levelChunk) {
         this.chunks.add(levelChunk);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(levelChunk);
     }
 
     public void removeChunk(final LevelChunk levelChunk) {
         this.chunks.remove(levelChunk);
-        TickRegions.RegionStats.updateCurrentRegion();
+        TickRegions.RegionStats.updateCurrentRegion(levelChunk);
     }
 
     public IteratorSafeOrderedReferenceSet<LevelChunk> getChunks() {
diff --git a/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java b/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
index fd0053369eb68f0fd596d8acfba4a5247ef8105a..e14e5df2272168b45a04dd186d0e0144c6977fdb 100644
--- a/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
+++ b/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
@@ -14,6 +14,7 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
 import org.slf4j.Logger;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickData.java b/src/main/java/io/papermc/paper/threadedregions/TickData.java
index 29f9fed5f02530b3256e6b993e607d4647daa7b6..f414ef7cd151ed3ce79fd24f88fb2b7896616038 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickData.java
@@ -2,6 +2,7 @@ package io.papermc.paper.threadedregions;
 
 import ca.spottedleaf.concurrentutil.util.TimeUtil;
 import io.papermc.paper.util.IntervalledCounter;
+import io.papermc.paper.util.Tick;
 import it.unimi.dsi.fastutil.longs.LongArrayList;
 
 import java.util.ArrayDeque;
@@ -205,7 +206,7 @@ public final class TickData {
                         // Otherwise use the interval length.
                         // This is how differenceFromLastTick() works on TickTime when there is no previous interval.
                         differenceBetweenTicks = Math.max(
-                            TickRegionScheduler.TIME_BETWEEN_TICKS, totalTickTime
+                                TickRegionScheduler.NANOS_PER_TICK_PER_THREAD.getValue(), totalTickTime
                         );
                     }
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
index ab5f832aafc479eca1c5da012e180d6374e32325..f44277006412ce5db83d6d2f7bf871b61597d815 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -4,6 +4,8 @@ import ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool;
 import ca.spottedleaf.concurrentutil.util.TimeUtil;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.util.TickThread;
+import me.earthme.lightingluminol.tickcontroller.RegionTickHolder;
+import me.earthme.lightingluminol.utils.AccessibleThreadLocal;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.ChunkPos;
@@ -33,6 +35,8 @@ public final class TickRegionScheduler {
     public static final int TICK_RATE = 20;
     public static final long TIME_BETWEEN_TICKS = 1_000_000_000L / TICK_RATE; // ns
 
+    public static final AccessibleThreadLocal<Long> NANOS_PER_TICK_PER_THREAD = new AccessibleThreadLocal<>(() -> TIME_BETWEEN_TICKS);
+
     private final SchedulerThreadPool scheduler;
 
     public TickRegionScheduler(final int threads) {
@@ -210,9 +214,9 @@ public final class TickRegionScheduler {
 
     // By using our own thread object, we can use a field for the current region rather than a ThreadLocal.
     // This is much faster than a thread local, since the thread local has to use a map lookup.
-    private static final class TickThreadRunner extends TickThread {
+    public static final class TickThreadRunner extends TickThread {
 
-        private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion;
+        public ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion; //Make it public
         private RegionizedWorldData currentTickingWorldRegionizedData;
         private SchedulerThreadPool.SchedulableTick currentTickingTask;
         // Folia start - profiler
@@ -221,6 +225,7 @@ public final class TickRegionScheduler {
 
         public TickThreadRunner(final Runnable run, final String name) {
             super(run, name);
+            RegionTickHolder.INSTANCE.onRegionRunnerCreated(this); //Molia - For datapack command
         }
     }
 
@@ -255,7 +260,7 @@ public final class TickRegionScheduler {
             this.region = region;
 
             this.setScheduledStart(firstStart);
-            this.tickSchedule = new Schedule(firstStart == SchedulerThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - TIME_BETWEEN_TICKS);
+            this.tickSchedule = new Schedule(firstStart == SchedulerThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - NANOS_PER_TICK_PER_THREAD.getValue());
         }
 
         /**
@@ -264,7 +269,7 @@ public final class TickRegionScheduler {
          */
         protected final void updateScheduledStart(final long to) {
             this.setScheduledStart(to);
-            this.tickSchedule.setLastPeriod(to == SchedulerThreadPool.DEADLINE_NOT_SET ? to : to - TIME_BETWEEN_TICKS);
+            this.tickSchedule.setLastPeriod(to == SchedulerThreadPool.DEADLINE_NOT_SET ? to : to - NANOS_PER_TICK_PER_THREAD.getValue());
         }
 
         public final void markNonSchedulable() {
@@ -292,6 +297,8 @@ public final class TickRegionScheduler {
 
         @Override
         public final Boolean runTasks(final BooleanSupplier canContinue) {
+            NANOS_PER_TICK_PER_THREAD.cleanDeathThreads();
+
             if (this.cancelled.get()) {
                 return null;
             }
@@ -364,7 +371,8 @@ public final class TickRegionScheduler {
             final long tickStart = System.nanoTime();
 
             // use max(), don't assume that tickStart >= scheduledStart
-            final int tickCount = Math.max(1, this.tickSchedule.getPeriodsAhead(TIME_BETWEEN_TICKS, tickStart));
+            final long actuallyTickTime = NANOS_PER_TICK_PER_THREAD.setValue(MinecraftServer.getServer().tickRateManager.nanosecondsPerTick()); //Luminol - For tick command
+            final int tickCount = Math.max(1, this.tickSchedule.getPeriodsAhead(actuallyTickTime, tickStart)); //Luminol - For tick command
 
             if (!this.tryMarkTicking()) {
                 if (!this.cancelled.get()) {
@@ -388,7 +396,7 @@ public final class TickRegionScheduler {
             this.lastTickStart = tickStart;
 
             final long scheduledStart = this.getScheduledStart();
-            final long scheduledEnd = scheduledStart + TIME_BETWEEN_TICKS;
+            final long scheduledEnd = scheduledStart + actuallyTickTime; //Luminol - For tick command
             new me.earthme.luminol.api.events.TickRegionStartTickEvent(this.region == null ? -1 : this.region.region.id,System.nanoTime()); //Luminol - Threaded regions API
             synchronized (this) {
                 this.currentTickData = new TickTime(
@@ -416,8 +424,8 @@ public final class TickRegionScheduler {
                 // in order to ensure all regions get their chance at scheduling, we have to ensure that regions
                 // that exceed the max tick time are not always prioritised over everything else. Thus, we use the greatest
                 // of the current time and "ideal" next tick start.
-                this.tickSchedule.advanceBy(tickCount, TIME_BETWEEN_TICKS);
-                this.setScheduledStart(TimeUtil.getGreatestTime(tickEnd, this.tickSchedule.getDeadline(TIME_BETWEEN_TICKS)));
+                this.tickSchedule.advanceBy(tickCount, actuallyTickTime); //Luminol - For tick command
+                this.setScheduledStart(TimeUtil.getGreatestTime(tickEnd, this.tickSchedule.getDeadline(actuallyTickTime))); //Luminol - For tick command
 
                 final TickTime time = new TickTime(
                     lastTickStart, scheduledStart, tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, true
@@ -563,7 +571,7 @@ public final class TickRegionScheduler {
             if (this.hasLastTick()) {
                 return this.tickStart - this.previousTickStart;
             }
-            return Math.max(TIME_BETWEEN_TICKS, this.tickLength());
+            return Math.max(NANOS_PER_TICK_PER_THREAD.getValue(), this.tickLength());
         }
 
         /**
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index 78c50292fb25e8703e9c91db892f05456f07d72f..efdfd5b514e6f0368275f0c9d63c38a6a1c30faf 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -12,6 +12,8 @@ import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.slf4j.Logger;
 import java.util.Iterator;
 import java.util.concurrent.TimeUnit;
@@ -153,6 +155,28 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             this.chunkCount.setRelease(data == null ? 0 : data.getChunkCount());
         }
 
+        static void updateCurrentRegion(Entity entity) {
+            ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+                    TickRegionScheduler.getCurrentRegion();
+
+            if (region == null){
+                region = ((ServerLevel) entity.level()).regioniser.getRegionAtUnsynchronised(entity.getBlockX() >> 4,entity.getBlockZ() >> 4);
+            }
+
+            region.getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+        }
+
+        static void updateCurrentRegion(LevelChunk chunk) {
+            ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+                    TickRegionScheduler.getCurrentRegion();
+
+            if (region == null){
+                region = chunk.level.regioniser.getRegionAtUnsynchronised(chunk.locX,chunk.locZ);
+            }
+
+            region.getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+        }
+
         static void updateCurrentRegion() {
             TickRegionScheduler.getCurrentRegion().getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
         }
@@ -227,6 +251,10 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             ret = regionizedData.createNewValue();
             this.regionizedData.put(regionizedData, ret);
 
+            if (ret instanceof RegionizedWorldData data){
+                data.world.dataSwitcher.updateCurrent(data);
+            }
+
             return ret;
         }
 
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index 620e12a38c67230ad8591a4a32bcb932426356cc..d0bbed2de43a91af33e470c87657f741513fcdbc 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -18,6 +18,8 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class TickThread extends Thread {
@@ -38,7 +40,7 @@ public class TickThread extends Thread {
         if (!STRICT_THREAD_CHECKS) {
             return;
         }
-        ensureTickThread(reason);
+        //ensureTickThread(reason);
     }
 
     /**
@@ -47,50 +49,50 @@ public class TickThread extends Thread {
     @Deprecated
     public static void ensureTickThread(final String reason) {
         if (!isTickThread()) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+           // throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final BlockPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final ChunkPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final int chunkX, final int chunkZ, final String reason) {
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Entity entity, final String reason) {
         if (!isTickThreadFor(entity)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final AABB aabb, final String reason) {
         if (!isTickThreadFor(world, aabb)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+           // throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final double blockX, final double blockZ, final String reason) {
         if (!isTickThreadFor(world, blockX, blockZ)) {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            //throw new IllegalStateException(reason);
         }
     }
 
diff --git a/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java b/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..a714c1a1443901913fb39634e97d49bc6319a24e
--- /dev/null
+++ b/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java
@@ -0,0 +1,15 @@
+package me.earthme.lightingluminol;
+
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+
+public class RegonizedWorldDataSwitcher {
+    private volatile RegionizedWorldData lastMatch = null;
+
+    public RegionizedWorldData getLastMatch(){
+        return this.lastMatch;
+    }
+
+    public void updateCurrent(RegionizedWorldData data){
+        this.lastMatch = data;
+    }
+}
diff --git a/src/main/java/me/earthme/lightingluminol/SchedulerUtil.java b/src/main/java/me/earthme/lightingluminol/SchedulerUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..e022464207f271e0f2047ec60ff593bc84bba6d9
--- /dev/null
+++ b/src/main/java/me/earthme/lightingluminol/SchedulerUtil.java
@@ -0,0 +1,31 @@
+package me.earthme.lightingluminol;
+
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.function.Supplier;
+
+public class SchedulerUtil {
+    public static final MinecraftInternalPlugin NULL_PLUG = new MinecraftInternalPlugin();
+
+    public static Executor regionSchedulerAsExecutor(int chunkX, int chunkZ, ServerLevel level){
+        return task -> Bukkit.getRegionScheduler().execute(NULL_PLUG,level.getWorld(),chunkX,chunkZ,task);
+    }
+
+    public static Executor regionSchedulerAsExecutor(World world,int x,int z){
+        return task -> Bukkit.getRegionScheduler().execute(NULL_PLUG,world,x,z,task);
+    }
+
+    public static boolean checkOnTargetScheduler(Location location){
+        return Bukkit.isOwnedByCurrentRegion(location);
+    }
+
+    public static <T> T ensureOnTargetRegion(World world,int x,int z,Supplier<T> act){
+        return CompletableFuture.supplyAsync(act,regionSchedulerAsExecutor(world,x,z)).join();
+    }
+}
diff --git a/src/main/java/me/earthme/lightingluminol/tickcontroller/RegionTickHolder.java b/src/main/java/me/earthme/lightingluminol/tickcontroller/RegionTickHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a3b02e39e6c1558250cebb5ada29f25f5c963b4
--- /dev/null
+++ b/src/main/java/me/earthme/lightingluminol/tickcontroller/RegionTickHolder.java
@@ -0,0 +1,121 @@
+package me.earthme.lightingluminol.tickcontroller;
+
+import com.google.common.collect.Maps;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class RegionTickHolder {
+    public static final RegionTickHolder INSTANCE = new RegionTickHolder();
+
+    private final AtomicInteger totalCreated = new AtomicInteger();
+    private final AtomicInteger totalTicking = new AtomicInteger();
+    private final AtomicInteger totalIdle = new AtomicInteger();
+    private final AtomicBoolean schedulerRunnerBlocked = new AtomicBoolean(false);
+    private volatile boolean global_shouldRunNextTick = true;
+    private final Map<TickRegionScheduler.TickThreadRunner,Boolean> single_shouldRunNextTick = Maps.newConcurrentMap();
+    private final Lock accessLock = new ReentrantLock(true);
+
+    public List<TickRegionScheduler.TickThreadRunner> getAllRegistedTickThreads(){
+        this.accessLock.lock();
+        try {
+            return new ArrayList<>(this.single_shouldRunNextTick.keySet());
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public void updateSchedulerRunnerStats(boolean blocked){
+        this.schedulerRunnerBlocked.set(blocked);
+    }
+
+    public void releaseAllTickRunners(){
+        this.accessLock.lock();
+        try {
+            this.global_shouldRunNextTick = true;
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public void awaitAllTickRunnerIdle(){
+        for(;;){
+            if (this.totalTicking.get() == 0 && this.schedulerRunnerBlocked.get()){
+                this.accessLock.lock();
+                try {
+                    if (this.totalIdle.get() == this.single_shouldRunNextTick.size()){
+                        break;
+                    }
+                }finally {
+                    this.accessLock.unlock();
+                }
+            }
+
+            LockSupport.parkNanos(1_000_000L);
+        }
+    }
+
+    public void blockAllTickRunners(){
+        this.accessLock.lock();
+        try {
+            this.global_shouldRunNextTick = false;
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public void onRegionBreakOutIdle(){
+        this.totalIdle.getAndDecrement();
+    }
+
+    public void onRegionRunnerIdle(){
+        this.totalIdle.getAndIncrement();
+    }
+
+    public void onRegionRunnerFinishedCurrentTick(){
+        this.totalTicking.getAndDecrement();
+    }
+
+    public void onRegionRunnerStartTicking(){
+        this.totalTicking.getAndIncrement();
+    }
+
+    public void onRegionRunnerCreated(TickRegionScheduler.TickThreadRunner worker){
+        this.accessLock.lock();
+        try {
+            if (!this.global_shouldRunNextTick){
+                this.single_shouldRunNextTick.putIfAbsent(worker,false);
+            }
+
+            this.single_shouldRunNextTick.putIfAbsent(worker,true);
+        }finally {
+            this.accessLock.unlock();
+        }
+        this.totalCreated.getAndIncrement();
+    }
+
+    public void onRegionRunnerDestroyed(TickRegionScheduler.TickThreadRunner worker){
+        this.accessLock.lock();
+        try {
+            this.single_shouldRunNextTick.remove(worker);
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public boolean shouldRunNextTick(TickRegionScheduler.TickThreadRunner worker){
+        this.accessLock.lock();
+        try {
+            return this.global_shouldRunNextTick && this.single_shouldRunNextTick.get(worker) || !this.schedulerRunnerBlocked.get();
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+}
diff --git a/src/main/java/me/earthme/lightingluminol/utils/AccessibleThreadLocal.java b/src/main/java/me/earthme/lightingluminol/utils/AccessibleThreadLocal.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd97e13ed1e2dc6576c26f32de4b0d390ba323af
--- /dev/null
+++ b/src/main/java/me/earthme/lightingluminol/utils/AccessibleThreadLocal.java
@@ -0,0 +1,89 @@
+package me.earthme.lightingluminol.utils;
+
+import com.google.common.collect.Maps;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+public class AccessibleThreadLocal<V> {
+    private final Map<Thread,V> allValues = Maps.newHashMap();
+    private final Lock accessLock = new ReentrantLock();
+    private final Supplier<V> valueCreator;
+
+    public AccessibleThreadLocal(Supplier<V> valueCretor) {
+        this.valueCreator = valueCretor;
+    }
+
+    public AccessibleThreadLocal(){
+        this.valueCreator = null;
+    }
+
+    public V getValue(){
+        this.accessLock.lock();
+        try {
+            if (!this.allValues.containsKey(Thread.currentThread())) {
+                this.allValues.put(Thread.currentThread(),this.valueCreator == null ? null : this.valueCreator.get());
+            }
+
+            return this.allValues.get(Thread.currentThread());
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public V setValue(V newValue){
+        this.accessLock.lock();
+        try {
+            if (!this.allValues.containsKey(Thread.currentThread())){
+                this.allValues.put(Thread.currentThread(),newValue);
+            }
+            this.allValues.replace(Thread.currentThread(),newValue);
+        }finally {
+            this.accessLock.unlock();
+        }
+        return newValue;
+    }
+
+    public void cleanDeathThreads(){
+        this.accessLock.lock();
+        try {
+            final List<Thread> toRemove = new ArrayList<>();
+
+            for (Map.Entry<Thread,V> perEntry : this.allValues.entrySet()){
+                if (!perEntry.getKey().isAlive()){
+                    toRemove.add(perEntry.getKey());
+                }
+            }
+
+            for (Thread beingRemoved : toRemove){
+                this.allValues.remove(beingRemoved);
+            }
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public void setAll(V newValue){
+        this.accessLock.lock();
+        try {
+            final List<Thread> toSet = new ArrayList<>();
+
+            for (Map.Entry<Thread,V> perEntry : this.allValues.entrySet()){
+                if (perEntry.getKey().isAlive()){
+                    toSet.add(perEntry.getKey());
+                }
+            }
+
+            for (Thread beingSet : toSet){
+                this.allValues.replace(beingSet,newValue);
+            }
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 1be341252cd0db3b5166eb04f7334b3bb3c814af..47dd58e0d99767d8f4808e5560039be63b2631ad 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -3,9 +3,6 @@ package net.minecraft.server;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
-import co.aikar.timings.Timings;
-import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
-import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -14,6 +11,7 @@ import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.threadedregions.RegionizedServer;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import java.awt.image.BufferedImage;
@@ -109,9 +107,7 @@ import net.minecraft.util.ProgressListener;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.SignatureValidator;
 import net.minecraft.util.TimeUtil;
-import net.minecraft.util.Unit;
 import net.minecraft.util.datafix.DataFixers;
-import net.minecraft.util.profiling.EmptyProfileResults;
 import net.minecraft.util.profiling.ProfileResults;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.profiling.ResultField;
@@ -153,7 +149,6 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 import net.minecraft.world.level.storage.WorldData;
 import net.minecraft.world.level.storage.loot.LootDataManager;
 import org.slf4j.Logger;
-
 // CraftBukkit start
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
@@ -184,8 +179,6 @@ import net.minecraft.world.level.validation.ContentValidationException;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.Bukkit;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.Main;
 import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
@@ -282,7 +275,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private String serverId;
     public MinecraftServer.ReloadableResources resources;
     private final StructureTemplateManager structureTemplateManager;
-    private final ServerTickRateManager tickRateManager;
+    public final ServerTickRateManager tickRateManager; //Luminol - private -> public
     protected WorldData worldData;
     private volatile boolean isSaving;
 
@@ -2232,7 +2225,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public int getTickCount() {
-        throw new UnsupportedOperationException(); // Folia - region threading
+        //throw new UnsupportedOperationException(); // Folia - region threading
+        return ((int) RegionizedServer.getGlobalTickData().getCurrentTick());
     }
 
     public int getSpawnProtectionRadius() {
@@ -2365,7 +2359,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             Objects.requireNonNull(this.packRepository);
             return stream.<Pack>map(resourcepackrepository::getPack).filter(Objects::nonNull).map(Pack::open).collect(ImmutableList.toImmutableList()); // CraftBukkit - decompile error // Paper - decompile error // todo: is this needed anymore?
-        }, this).thenCompose((immutablelist) -> {
+        },this).thenCompose((immutablelist) -> {
             MultiPackResourceManager resourcemanager = new MultiPackResourceManager(PackType.SERVER_DATA, immutablelist);
 
             return ReloadableServerResources.loadResources(resourcemanager, iregistrycustom_dimension, this.worldData.enabledFeatures(), this.isDedicatedServer() ? Commands.CommandSelection.DEDICATED : Commands.CommandSelection.INTEGRATED, this.getFunctionCompilationLevel(), this.executor, this).whenComplete((datapackresources, throwable) -> {
@@ -2387,9 +2381,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.resources.managers.updateRegistryTags(this.registryAccess());
             net.minecraft.world.item.alchemy.PotionBrewing.reload(); // Paper - Custom Potion Mixes
             // Paper start
-            if (Thread.currentThread() != this.serverThread) {
-                return;
-            }
             // this.getPlayerList().saveAll(); // Paper - we don't need to save everything, just advancements
             for (ServerPlayer player : this.getPlayerList().getPlayers()) {
                 player.getAdvancements().save();
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 74483543836d9ed042cc7b9cbbde8d58d6994475..ea830d500a3b26ef4c87f9d4b7e9136e1223c922 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -11,6 +11,10 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.util.TickThread;
+import me.earthme.lightingluminol.SchedulerUtil;
+
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
@@ -200,9 +204,9 @@ public class ServerChunkCache extends ChunkSource {
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
         if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
-            return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
+            return CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
-            }, this.mainThreadProcessor).join();
+            }, SchedulerUtil.regionSchedulerAsExecutor(this.level.getWorld(),x,z)).join();
         } else {
             // Paper start - Perf: Optimise getChunkAt calls for loaded chunks
             LevelChunk ifLoaded = this.getChunkAtIfLoadedMainThread(x, z);
@@ -228,7 +232,11 @@ public class ServerChunkCache extends ChunkSource {
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.pushChunkWait(this.level, x1, z1); // Paper - rewrite chunk system
                 com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.level, x, z); // Paper - Add debug for sync chunk loads
                 this.level.timings.syncChunkLoad.startTiming(); // Paper
-            chunkproviderserver_b.managedBlock(completablefuture::isDone);
+                if (!RegionizedServer.isGlobalTickThread() || !TickThread.isTickThreadFor(this.level,x,z)){
+                    chunkproviderserver_b.managedBlock(completablefuture::isDone);
+                }else{
+                    completablefuture.join();
+                }
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.popChunkWait(); // Paper - rewrite chunk system
                 this.level.timings.syncChunkLoad.stopTiming(); // Paper
             } // Paper
@@ -876,8 +884,10 @@ public class ServerChunkCache extends ChunkSource {
         // CraftBukkit start - process pending Chunk loadCallback() and unloadCallback() after each run task
         public boolean pollTask() {
             // Folia start - region threading
-            if (ServerChunkCache.this.level != io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().world) {
-                throw new IllegalStateException("Polling tasks from non-owned region");
+            if (!RegionizedServer.isGlobalTickThread()){
+                if (ServerChunkCache.this.level != io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().world) {
+                    throw new IllegalStateException("Polling tasks from non-owned region");
+                }
             }
             // Folia end - region threading
             if (ServerChunkCache.this.runDistanceManagerUpdates()) {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index ba33c107cfbe9920fc33375daf8e6b62cc794d98..ee6978f2ddb75765cfa94f614b0016800d748997 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -2052,7 +2053,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
             List<PathNavigation> list = new ObjectArrayList();
-            Iterator iterator = this.getCurrentWorldData().getNavigatingMobs(); // Folia - region threading
+            Iterator iterator = this.getCurrentWorldData().getNavigatingMobs().iterator(); // Folia - region threading
 
             while (iterator.hasNext()) {
                 // CraftBukkit start - fix SPIGOT-6362
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 83701fbfaa56a232593ee8f11a3afb8941238bfa..5815afa3a85e23b25aa04acb5ac61bc39892b658 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -10,6 +10,8 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.util.profiling.metrics.MetricCategory;
 import net.minecraft.util.profiling.metrics.MetricSampler;
 import net.minecraft.util.profiling.metrics.MetricsRegistry;
@@ -71,7 +73,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public void executeBlocking(Runnable runnable) {
-        if (!this.isSameThread()) {
+        if (!this.isSameThread() && !TickThread.isTickThread()) { //Molia - for data pack command
             this.submitAsync(runnable).join();
         } else {
             runnable.run();
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 8a0cf571195fa8f8771a03cba329dac294bdbece..0d1eb3540d0e844e4cf993ccd173bc5a4dbc2c51 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -125,6 +125,8 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.ScoreHolder;
 import net.minecraft.world.scores.Team;
+import org.bukkit.event.player.PlayerPortalEvent;
+import io.papermc.paper.util.MCUtil;
 import org.joml.Vector3f;
 import org.slf4j.Logger;
 import org.bukkit.Bukkit;
@@ -3932,7 +3934,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                     for (EntityTreeNode node : fullTree) {
                         node.root.placeSingleSync(originWorld, destination, node, teleportFlags);
                     }
-
                     // restore passenger tree
                     passengerTree.restore();
                     passengerTree.adjustRiders(true);
@@ -4047,7 +4048,15 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         if (!this.canTeleportAsync()) {
             return false;
         }
-        this.getBukkitEntity(); // force bukkit entity to be created before TPing
+
+        final org.bukkit.entity.Entity bukkitEntity = this.getBukkitEntity(); // force bukkit entity to be created before TPing
+
+        if (!this.preventMoving && this instanceof ServerPlayer) {
+            if (!new PlayerTeleportEvent((org.bukkit.entity.Player) bukkitEntity,bukkitEntity.getLocation(), MCUtil.toLocation(destination,pos)).callEvent()){
+                return false;
+            }
+        }
+
         if ((teleportFlags & TELEPORT_FLAG_UNMOUNT) == 0L) {
             for (Entity entity : this.getIndirectPassengers()) {
                 if (!entity.canTeleportAsync()) {
@@ -4481,6 +4490,21 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                 // we just have to abandon this teleport to prevent duplication
                 return;
             }
+
+            if (this instanceof ServerPlayer){
+                final org.bukkit.entity.Player bukkitPlayer = ((ServerPlayer) this).getBukkitEntity();
+                PlayerTeleportEvent.TeleportCause cause = PlayerTeleportEvent.TeleportCause.UNKNOWN;
+
+                switch (type){
+                    case END -> cause = PlayerTeleportEvent.TeleportCause.END_PORTAL;
+                    case NETHER -> cause = PlayerTeleportEvent.TeleportCause.NETHER_PORTAL;
+                }
+
+                final PlayerPortalEvent eventWrapped = new PlayerPortalEvent(bukkitPlayer,MCUtil.toLocation(originWorld,initialPosition),MCUtil.toLocation(destination,info.pos),cause,0,true, 0);
+                eventWrapped.callEvent();
+                info.pos = MCUtil.toVec3(eventWrapped.getTo());
+            }
+
             originWorld.chunkSource.removeTicketAtLevel(
                 TicketType.TELEPORT_HOLD_TICKET, initialPositionChunk,
                 io.papermc.paper.chunk.system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL,
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 3cd8573db9dadb2e32f3c107f4812b525db014b1..90dbd2064f0ec86b92456c98d9a3f4e6729cf177 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -10,6 +10,9 @@ import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+import me.earthme.lightingluminol.RegonizedWorldDataSwitcher;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -214,16 +217,19 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     );
     public volatile io.papermc.paper.threadedregions.RegionizedServer.WorldLevelData tickData;
     public final java.util.concurrent.ConcurrentHashMap.KeySetView<net.minecraft.server.level.ChunkHolder, Boolean> needsChangeBroadcasting = java.util.concurrent.ConcurrentHashMap.newKeySet();
+    public final RegonizedWorldDataSwitcher dataSwitcher = new RegonizedWorldDataSwitcher();
 
     public io.papermc.paper.threadedregions.RegionizedWorldData getCurrentWorldData() {
         final io.papermc.paper.threadedregions.RegionizedWorldData ret = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData();
         if (ret == null) {
-            return ret;
+            return this.dataSwitcher.getLastMatch();
         }
         Level world = ret.world;
         if (world != this) {
-            throw new IllegalStateException("World mismatch: expected " + this.getWorld().getName() + " but got " + world.getWorld().getName());
+            //throw new IllegalStateException("World mismatch: expected " + this.getWorld().getName() + " but got " + world.getWorld().getName());
+            return this.dataSwitcher.getLastMatch();
         }
+        this.dataSwitcher.updateCurrent(ret);
         return ret;
     }
 
diff --git a/src/main/java/net/minecraft/world/level/portal/PortalInfo.java b/src/main/java/net/minecraft/world/level/portal/PortalInfo.java
index 34c0d9fe03cc834e949889f9c4f8269206c18040..4953371d205a1c3982a29252a51dcc99b1f5e99a 100644
--- a/src/main/java/net/minecraft/world/level/portal/PortalInfo.java
+++ b/src/main/java/net/minecraft/world/level/portal/PortalInfo.java
@@ -7,7 +7,7 @@ import org.bukkit.craftbukkit.event.CraftPortalEvent;
 
 public class PortalInfo {
 
-    public final Vec3 pos;
+    public Vec3 pos;
     public final Vec3 speed;
     public final float yRot;
     public final float xRot;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index ead0e0d84d47b227a79c18ea5e0538705b4ff0f3..6899d579da676b63812d717c6a21c9621bd60619 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -14,6 +14,7 @@ import com.mojang.brigadier.tree.CommandNode;
 import com.mojang.brigadier.tree.LiteralCommandNode;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
+import io.papermc.paper.threadedregions.RegionizedServer;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import java.awt.image.BufferedImage;
 import java.io.ByteArrayOutputStream;
@@ -37,6 +38,8 @@ import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.LockSupport;
 import java.util.function.Consumer;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -265,6 +268,8 @@ import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
+import static org.bukkit.craftbukkit.scheduler.CraftScheduler.MINECRAFT;
+
 public final class CraftServer implements Server {
     private final String serverName = "LightingLuminol"; // Folia // Paper //Luminol //LightingLuminol
     private final String serverVersion;
@@ -1286,7 +1291,6 @@ public final class CraftServer implements Server {
 
     @Override
     public World createWorld(WorldCreator creator) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
         Preconditions.checkState(this.console.getAllLevels().iterator().hasNext(), "Cannot create additional worlds on STARTUP");
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot create a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         Preconditions.checkArgument(creator != null, "WorldCreator cannot be null");
@@ -1423,7 +1427,7 @@ public final class CraftServer implements Server {
         // Paper start - fix and optimise world upgrading
         if (this.console.options.has("forceUpgrade")) {
             net.minecraft.server.Main.convertWorldButItWorks(
-                actualDimension,  worldSession, DataFixers.getDataFixer(), worlddimension.generator().getTypeNameForDataFixer(), this.console.options.has("eraseCache")
+                    actualDimension, worldSession, DataFixers.getDataFixer(), worlddimension.generator().getTypeNameForDataFixer(), this.console.options.has("eraseCache")
             );
         }
         // Paper end - fix and optimise world upgrading
@@ -1446,7 +1450,20 @@ public final class CraftServer implements Server {
         }
 
         this.console.addLevel(internal); // Paper - Put world into worldlist before initing the world; move up
-        this.console.initWorld(internal, worlddata, worlddata, worlddata.worldGenOptions());
+        //this.console.initWorld(internal, worlddata, worlddata, worlddata.worldGenOptions());
+
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addWorld(internal);
+        int loadRegionRadius = ((32) >> 4);
+        internal.randomSpawnSelection = new net.minecraft.world.level.ChunkPos(internal.getChunkSource().randomState().sampler().findSpawnPosition());
+        for (int currX = -loadRegionRadius; currX <= loadRegionRadius; ++currX) {
+            for (int currZ = -loadRegionRadius; currZ <= loadRegionRadius; ++currZ) {
+                net.minecraft.world.level.ChunkPos pos = new net.minecraft.world.level.ChunkPos(currX, currZ);
+                internal.chunkSource.addTicketAtLevel(
+                        TicketType.UNKNOWN, pos, io.papermc.paper.chunk.system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, pos
+                );
+            }
+        }
+        //Folia end
 
         internal.setSpawnSettings(true, true);
         // Paper - Put world into worldlist before initing the world; move up
@@ -1465,7 +1482,7 @@ public final class CraftServer implements Server {
 
     @Override
     public boolean unloadWorld(World world, boolean save) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
+        //if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot unload a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         if (world == null) {
             return false;
@@ -1493,13 +1510,40 @@ public final class CraftServer implements Server {
         }
 
         try {
-            if (save) {
-                handle.save(null, true, false); // Paper - Fix saving in unloadWorld
-            }
+            if (RegionizedServer.isGlobalTickThread()) {
+                try {
+                    if (save) {
+                        handle.save(null, true, false); // Paper - don't disable saving
+                    }
 
-            handle.getChunkSource().close(save);
-            // handle.entityManager.close(save); // SPIGOT-6722: close entityManager // Paper - rewrite chunk system
-            handle.convertable.close();
+                    handle.getChunkSource().close(save);
+                    // handle.entityManager.close(save); // SPIGOT-6722: close entityManager // Paper - rewrite chunk system
+                    handle.convertable.close();
+                } catch (Exception ex) {
+                    this.getLogger().log(Level.SEVERE, null, ex);
+                }
+            } else {
+                final AtomicBoolean finished = new AtomicBoolean(false);
+                Bukkit.getGlobalRegionScheduler().run(MINECRAFT, t -> {
+                    try {
+                        if (save) {
+                            handle.save(null, true, false); // Paper - don't disable saving
+                        }
+
+                        handle.getChunkSource().close(save);
+                        // handle.entityManager.close(save); // SPIGOT-6722: close entityManager // Paper - rewrite chunk system
+                        handle.convertable.close();
+                    } catch (Exception ex) {
+                        this.getLogger().log(Level.SEVERE, null, ex);
+                    } finally {
+                        finished.set(true);
+                    }
+                });
+
+                while (!finished.get()) {
+                    LockSupport.parkNanos(1_000_000L);
+                }
+            }
         } catch (Exception ex) {
             this.getLogger().log(Level.SEVERE, null, ex);
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index becb3b07876715d7c39ba4e7289cc5ac85f84412..f5a57709376c20544dc2d63f6fa682c511e44ef6 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -147,6 +147,7 @@ import org.bukkit.util.StructureSearchResult;
 import org.bukkit.util.Vector;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import net.minecraft.world.level.Level;
 
 public class CraftWorld extends CraftRegionAccessor implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -385,7 +386,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public boolean isChunkGenerated(int x, int z) {
         // Paper start - Fix this method
-        if (!io.papermc.paper.util.TickThread.isTickThreadFor(this.getHandle(), x, z)) { // Folia - region threading
+        if (!io.papermc.paper.util.TickThread.isTickThreadFor(this.getHandle(), x, z) && !io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread()) { // Folia - region threading
             return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
                 return CraftWorld.this.isChunkGenerated(x, z);
             }, (run) -> { io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(this.getHandle(), x, z, run);}).join(); // Folia - region threading
@@ -495,7 +496,11 @@ public class CraftWorld extends CraftRegionAccessor implements World {
                 },
                 list
             );
-            serverChunkCache.mainThreadProcessor.managedBlock(future::isDone);
+            if (!io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread()) {
+                serverChunkCache.mainThreadProcessor.managedBlock(future::isDone);
+            }else{
+                future.join();
+            }
             if (chunkStatus == ChunkStatus.NOISE) {
                 future.join().left().ifPresent(chunk -> net.minecraft.world.level.levelgen.Heightmap.primeHeightmaps(chunk, ChunkStatus.POST_FEATURES));
             }
@@ -888,7 +893,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setTime(long time) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
         long margin = (time - this.getFullTime()) % 24000;
         if (margin < 0) margin += 24000;
         this.setFullTime(this.getFullTime() + margin);
@@ -901,7 +906,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setFullTime(long time) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
         // Notify anyone who's listening
         TimeSkipEvent event = new TimeSkipEvent(this, TimeSkipEvent.SkipReason.CUSTOM, time - this.world.getDayTime());
         this.server.getPluginManager().callEvent(event);
@@ -1374,7 +1379,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setStorm(boolean hasStorm) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setRaining(hasStorm, org.bukkit.event.weather.WeatherChangeEvent.Cause.PLUGIN); // Paper - Add cause to Weather/ThunderChangeEvents
         this.setWeatherDuration(0); // Reset weather duration (legacy behaviour)
         this.setClearWeatherDuration(0); // Reset clear weather duration (reset "/weather clear" commands)
@@ -1387,7 +1392,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setWeatherDuration(int duration) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setRainTime(duration);
     }
 
@@ -1398,7 +1403,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setThundering(boolean thundering) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setThundering(thundering, org.bukkit.event.weather.ThunderChangeEvent.Cause.PLUGIN); // Paper - Add cause to Weather/ThunderChangeEvents
         this.setThunderDuration(0); // Reset weather duration (legacy behaviour)
         this.setClearWeatherDuration(0); // Reset clear weather duration (reset "/weather clear" commands)
@@ -1411,7 +1416,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setThunderDuration(int duration) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setThunderTime(duration);
     }
 
@@ -1422,7 +1427,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setClearWeatherDuration(int duration) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setClearWeatherTime(duration);
     }
 
@@ -1617,7 +1622,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setKeepSpawnInMemory(boolean keepLoaded) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify keep spawn in memory off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify keep spawn in memory off of the global region"); // Folia - region threading
         // Paper start - Configurable spawn radius
         if (keepLoaded == this.world.keepSpawnInMemory) {
             // do nothing, nothing has changed
@@ -1696,7 +1701,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setHardcore(boolean hardcore) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.world.serverLevelData.settings.hardcore = hardcore;
     }
 
@@ -1709,7 +1714,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.ANIMAL, ticksPerAnimalSpawns);
     }
 
@@ -1722,7 +1727,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.MONSTER, ticksPerMonsterSpawns);
     }
 
@@ -1735,7 +1740,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_ANIMAL, ticksPerWaterSpawns);
     }
 
@@ -1748,7 +1753,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterAmbientSpawns(int ticksPerWaterAmbientSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_AMBIENT, ticksPerWaterAmbientSpawns);
     }
 
@@ -1761,7 +1766,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_UNDERGROUND_CREATURE, ticksPerWaterUndergroundCreatureSpawns);
     }
 
@@ -1774,13 +1779,13 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.AMBIENT, ticksPerAmbientSpawns);
     }
 
     @Override
     public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(spawnCategory != null, "SpawnCategory cannot be null");
         Preconditions.checkArgument(CraftSpawnCategory.isValidForLimits(spawnCategory), "SpawnCategory.%s are not supported", spawnCategory);
 
@@ -1797,25 +1802,25 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
         this.server.getWorldMetadata().setMetadata(this, metadataKey, newMetadataValue);
     }
 
     @Override
     public List<MetadataValue> getMetadata(String metadataKey) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
         return this.server.getWorldMetadata().getMetadata(this, metadataKey);
     }
 
     @Override
     public boolean hasMetadata(String metadataKey) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
         return this.server.getWorldMetadata().hasMetadata(this, metadataKey);
     }
 
     @Override
     public void removeMetadata(String metadataKey, Plugin owningPlugin) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
         this.server.getWorldMetadata().removeMetadata(this, metadataKey, owningPlugin);
     }
 
@@ -1828,7 +1833,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setMonsterSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.MONSTER, limit);
     }
 
@@ -1841,7 +1846,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setAnimalSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.ANIMAL, limit);
     }
 
@@ -1854,7 +1859,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterAnimalSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_ANIMAL, limit);
     }
 
@@ -1867,7 +1872,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterAmbientSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_AMBIENT, limit);
     }
 
@@ -1880,7 +1885,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterUndergroundCreatureSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_UNDERGROUND_CREATURE, limit);
     }
 
@@ -1893,7 +1898,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setAmbientSpawnLimit(int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.AMBIENT, limit);
     }
 
@@ -1916,7 +1921,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(spawnCategory != null, "SpawnCategory cannot be null");
         Preconditions.checkArgument(CraftSpawnCategory.isValidForLimits(spawnCategory), "SpawnCategory.%s are not supported", spawnCategory);
 
@@ -2100,7 +2105,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean setGameRuleValue(String rule, String value) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         // No null values allowed
         if (rule == null || value == null) return false;
 
@@ -2143,7 +2148,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
-        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
+        //io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(rule != null, "GameRule cannot be null");
         Preconditions.checkArgument(newValue != null, "GameRule value cannot be null");
 
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index b451b9df3233355fb16092edc3a4dd63d7d2ff14..083d644e4acee9e5f63bad9c9c045529022fa19e 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -15,6 +15,7 @@ import net.minecraft.world.item.BoneMealItem;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.item.context.UseOnContext;
 import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LightLayer;
 import net.minecraft.world.level.block.Blocks;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index a3f6e02bc4b2a62708efc94b44caf27cb9bf5c62..b748495ad88c0ea0e21a46fe5aca7df1f493bcea 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1309,7 +1309,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public boolean teleport(Location location, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, io.papermc.paper.entity.TeleportFlag... flags) {
         // Folia start - region threading
         if (true) {
-            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+            //throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+            return teleportAsync(location,cause).join();
         }
         // Folia end - region threading
         Set<io.papermc.paper.entity.TeleportFlag.Relative> relativeArguments;
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index b00e3b9b628f3d2a2fdbf1d2c77904963c16d3ac..e840a61bb05565db017532b10dd311ff7bc0b588 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -47,7 +47,7 @@ import org.bukkit.scheduler.BukkitWorker;
  */
 public class CraftScheduler implements BukkitScheduler {
 
-    static Plugin MINECRAFT = new MinecraftInternalPlugin();
+    public static Plugin MINECRAFT = new MinecraftInternalPlugin();
     /**
      * The start ID for the counter.
      */
@@ -109,8 +109,9 @@ public class CraftScheduler implements BukkitScheduler {
         }
     };
     private CraftAsyncDebugger debugTail = this.debugHead;
-
     */ // Paper end
+    //Molia start - For datapack command
+
     private static final int RECENT_TICKS;
 
     static {
@@ -532,7 +533,7 @@ public class CraftScheduler implements BukkitScheduler {
     }
 
     protected CraftTask handle(final CraftTask task, final long delay) { // Paper
-        if (true) throw new UnsupportedOperationException(); // Folia - region threading
+        //if (true) throw new UnsupportedOperationException(); // Folia - region threading //Molia - Disable this to support bukkit plugins
         // Paper start
         if (!this.isAsyncScheduler && !task.isSync()) {
             this.asyncScheduler.handle(task, delay);
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
index ce8b91f00f925960ad17f381162a11294e8b511d..506a8edda4fbf710b36919806ceb39b708641e37 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftScoreboard.java
@@ -44,8 +44,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
         return this.registerNewObjective(name, criteria, displayName, RenderType.INTEGER);
     }
     @Override
-    public CraftObjective registerNewObjective(String name, Criteria criteria, net.kyori.adventure.text.Component displayName, RenderType renderType) throws IllegalArgumentException {
-        if (true) throw new UnsupportedOperationException(); // Folia - not supported yet
+    public synchronized CraftObjective registerNewObjective(String name, Criteria criteria, net.kyori.adventure.text.Component displayName, RenderType renderType) throws IllegalArgumentException {
         if (displayName == null) {
             displayName = net.kyori.adventure.text.Component.empty();
         }
@@ -86,14 +85,14 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public Objective getObjective(String name) {
+    public synchronized Objective getObjective(String name) {
         Preconditions.checkArgument(name != null, "Objective name cannot be null");
         net.minecraft.world.scores.Objective nms = this.board.getObjective(name);
         return nms == null ? null : new CraftObjective(this, nms);
     }
 
     @Override
-    public ImmutableSet<Objective> getObjectivesByCriteria(String criteria) {
+    public synchronized ImmutableSet<Objective> getObjectivesByCriteria(String criteria) {
         Preconditions.checkArgument(criteria != null, "Criteria name cannot be null");
 
         ImmutableSet.Builder<Objective> objectives = ImmutableSet.builder();
@@ -107,7 +106,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<Objective> getObjectivesByCriteria(Criteria criteria) {
+    public synchronized ImmutableSet<Objective> getObjectivesByCriteria(Criteria criteria) {
         Preconditions.checkArgument(criteria != null, "Criteria cannot be null");
 
         ImmutableSet.Builder<Objective> objectives = ImmutableSet.builder();
@@ -122,12 +121,12 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<Objective> getObjectives() {
+    public synchronized ImmutableSet<Objective> getObjectives() {
         return ImmutableSet.copyOf(Iterables.transform(this.board.getObjectives(), (Function<net.minecraft.world.scores.Objective, Objective>) input -> new CraftObjective(CraftScoreboard.this, input)));
     }
 
     @Override
-    public Objective getObjective(DisplaySlot slot) {
+    public synchronized Objective getObjective(DisplaySlot slot) {
         Preconditions.checkArgument(slot != null, "Display slot cannot be null");
         net.minecraft.world.scores.Objective objective = this.board.getDisplayObjective(CraftScoreboardTranslations.fromBukkitSlot(slot));
         if (objective == null) {
@@ -142,7 +141,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<Score> getScores(String entry) {
+    public synchronized ImmutableSet<Score> getScores(String entry) {
         return this.getScores(CraftScoreboard.getScoreHolder(entry));
     }
 
@@ -162,7 +161,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public void resetScores(String entry) {
+    public synchronized void resetScores(String entry) {
         this.resetScores(CraftScoreboard.getScoreHolder(entry));
     }
 
@@ -175,7 +174,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public Team getPlayerTeam(OfflinePlayer player) {
+    public synchronized Team getPlayerTeam(OfflinePlayer player) {
         Preconditions.checkArgument(player != null, "OfflinePlayer cannot be null");
 
         PlayerTeam team = this.board.getPlayersTeam(player.getName());
@@ -183,7 +182,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public Team getEntryTeam(String entry) {
+    public synchronized Team getEntryTeam(String entry) {
         Preconditions.checkArgument(entry != null, "Entry cannot be null");
 
         PlayerTeam team = this.board.getPlayersTeam(entry);
@@ -191,7 +190,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public Team getTeam(String teamName) {
+    public synchronized Team getTeam(String teamName) {
         Preconditions.checkArgument(teamName != null, "Team name cannot be null");
 
         PlayerTeam team = this.board.getPlayerTeam(teamName);
@@ -199,13 +198,12 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<Team> getTeams() {
+    public synchronized ImmutableSet<Team> getTeams() {
         return ImmutableSet.copyOf(Iterables.transform(this.board.getPlayerTeams(), (Function<PlayerTeam, Team>) input -> new CraftTeam(CraftScoreboard.this, input)));
     }
 
     @Override
-    public Team registerNewTeam(String name) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not supported yet
+    public synchronized Team registerNewTeam(String name) {
         Preconditions.checkArgument(name != null, "Team name cannot be null");
         Preconditions.checkArgument(name.length() <= Short.MAX_VALUE, "Team name '%s' is longer than the limit of 32767 characters (%s)", name, name.length());
         Preconditions.checkArgument(this.board.getPlayerTeam(name) == null, "Team name '%s' is already in use", name);
@@ -214,7 +212,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<OfflinePlayer> getPlayers() {
+    public synchronized ImmutableSet<OfflinePlayer> getPlayers() {
         ImmutableSet.Builder<OfflinePlayer> players = ImmutableSet.builder();
         for (ScoreHolder playerName : this.board.getTrackedPlayers()) {
             players.add(Bukkit.getOfflinePlayer(playerName.getScoreboardName()));
@@ -223,7 +221,7 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public ImmutableSet<String> getEntries() {
+    public synchronized ImmutableSet<String> getEntries() {
         ImmutableSet.Builder<String> entries = ImmutableSet.builder();
         for (ScoreHolder entry : this.board.getTrackedPlayers()) {
             entries.add(entry.getScoreboardName());
@@ -232,27 +230,26 @@ public final class CraftScoreboard implements org.bukkit.scoreboard.Scoreboard {
     }
 
     @Override
-    public void clearSlot(DisplaySlot slot) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not supported yet
+    public synchronized void clearSlot(DisplaySlot slot) {
         Preconditions.checkArgument(slot != null, "Slot cannot be null");
         this.board.setDisplayObjective(CraftScoreboardTranslations.fromBukkitSlot(slot), null);
     }
 
     // Paper start
     @Override
-    public ImmutableSet<Score> getScoresFor(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
+    public synchronized ImmutableSet<Score> getScoresFor(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
         Preconditions.checkArgument(entity != null, "Entity cannot be null");
         return this.getScores(((org.bukkit.craftbukkit.entity.CraftEntity) entity).getHandle());
     }
 
     @Override
-    public void resetScoresFor(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
+    public synchronized void resetScoresFor(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
         Preconditions.checkArgument(entity != null, "Entity cannot be null");
         this.resetScores(((org.bukkit.craftbukkit.entity.CraftEntity) entity).getHandle());
     }
 
     @Override
-    public Team getEntityTeam(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
+    public synchronized Team getEntityTeam(org.bukkit.entity.Entity entity) throws IllegalArgumentException {
         Preconditions.checkArgument(entity != null, "Entity cannot be null");
         return this.getEntryTeam(((org.bukkit.craftbukkit.entity.CraftEntity) entity).getHandle().getScoreboardName());
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index d365e26799822f39af2d5a27761bb8b41308297e..ff0ae3516ea0427f0edc2128e5ab81b8d46aad6e 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -384,7 +384,7 @@ public final class CraftMagicNumbers implements UnsafeValues {
 
         // Folia start - block plugins not marked as supported
         if (!pdf.isFoliaSupported()) {
-            throw new InvalidPluginException("Plugin " + pdf.getFullName() + " is not marked as supporting regionised multithreading");
+            //throw new InvalidPluginException("Plugin " + pdf.getFullName() + " is not marked as supporting regionised multithreading");
         }
         // Folia end - block plugins not marked as supported
 
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 9e638f72f180ff5ef63ec3dd6cf548c53f7bd4a5..733f5a4f3721900e9cb52d599494316b9403ca58 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -5,6 +5,9 @@ import java.lang.management.MonitorInfo;
 import java.lang.management.ThreadInfo;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import me.earthme.lightingluminol.tickcontroller.RegionTickHolder;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
 
@@ -189,10 +192,14 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
                 }
                 // Paper end - Different message for short timeout
                 log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Paper!):" ); // Paper
+                log.log( Level.SEVERE, "Region thread dump:" ); // Paper
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(isLongTimeout); // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
-                WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
+                //WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
+                for (TickRegionScheduler.TickThreadRunner runner : RegionTickHolder.INSTANCE.getAllRegistedTickThreads()){
+                    WatchdogThread.dumpThread(ManagementFactory.getThreadMXBean().getThreadInfo(runner.getId()),log);
+                }
+                log.log( Level.SEVERE, "------------------------------" );
                 log.log( Level.SEVERE, "------------------------------" );
                 //
                 // Paper start - Only print full dump on long timeouts
