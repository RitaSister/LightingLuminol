From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrHua269 <novau233@163.com>
Date: Sun, 31 Mar 2024 00:53:02 +0000
Subject: [PATCH] Rework WorldData patches


diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index 78c50292fb25e8703e9c91db892f05456f07d72f..efdfd5b514e6f0368275f0c9d63c38a6a1c30faf 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -12,6 +12,8 @@ import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.slf4j.Logger;
 import java.util.Iterator;
 import java.util.concurrent.TimeUnit;
@@ -153,6 +155,28 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             this.chunkCount.setRelease(data == null ? 0 : data.getChunkCount());
         }
 
+        static void updateCurrentRegion(Entity entity) {
+            ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+                    TickRegionScheduler.getCurrentRegion();
+
+            if (region == null){
+                region = ((ServerLevel) entity.level()).regioniser.getRegionAtUnsynchronised(entity.getBlockX() >> 4,entity.getBlockZ() >> 4);
+            }
+
+            region.getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+        }
+
+        static void updateCurrentRegion(LevelChunk chunk) {
+            ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+                    TickRegionScheduler.getCurrentRegion();
+
+            if (region == null){
+                region = chunk.level.regioniser.getRegionAtUnsynchronised(chunk.locX,chunk.locZ);
+            }
+
+            region.getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+        }
+
         static void updateCurrentRegion() {
             TickRegionScheduler.getCurrentRegion().getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
         }
@@ -227,6 +251,10 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             ret = regionizedData.createNewValue();
             this.regionizedData.put(regionizedData, ret);
 
+            if (ret instanceof RegionizedWorldData data){
+                data.world.dataSwitcher.updateCurrent(data);
+            }
+
             return ret;
         }
 
diff --git a/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java b/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..a714c1a1443901913fb39634e97d49bc6319a24e
--- /dev/null
+++ b/src/main/java/me/earthme/lightingluminol/RegonizedWorldDataSwitcher.java
@@ -0,0 +1,15 @@
+package me.earthme.lightingluminol;
+
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+
+public class RegonizedWorldDataSwitcher {
+    private volatile RegionizedWorldData lastMatch = null;
+
+    public RegionizedWorldData getLastMatch(){
+        return this.lastMatch;
+    }
+
+    public void updateCurrent(RegionizedWorldData data){
+        this.lastMatch = data;
+    }
+}
diff --git a/src/main/java/me/earthme/lightingluminol/pool/WorldDataPool.java b/src/main/java/me/earthme/lightingluminol/pool/WorldDataPool.java
deleted file mode 100644
index 3e7f358a1a8623be58ef4f842f37b09beeb926e1..0000000000000000000000000000000000000000
--- a/src/main/java/me/earthme/lightingluminol/pool/WorldDataPool.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package me.earthme.lightingluminol.pool;
-
-import io.papermc.paper.threadedregions.RegionizedWorldData;
-import io.papermc.paper.threadedregions.ThreadedRegionizer;
-import io.papermc.paper.threadedregions.TickRegions;
-import net.minecraft.core.BlockPos;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.level.Level;
-import org.bukkit.Location;
-import org.bukkit.craftbukkit.CraftWorld;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-public class WorldDataPool {
-
-    @Nullable
-    public RegionizedWorldData getDataAnyThread(@NotNull Entity ent){
-        final RegionizedWorldData got = ent.level().getCurrentWorldDataUnsafe();
-        return got == null ? getDataOffTickThread((int)ent.position.x >> 4,(int)ent.position.z >> 4, (ServerLevel) ent.level()) : got; //Skip it if we got the current world data
-    }
-
-    @Nullable
-    public RegionizedWorldData getDataAnyThread(@NotNull Level level, BlockPos pos){
-        final RegionizedWorldData got = level.getCurrentWorldDataUnsafe();
-        return got == null ? getDataOffTickThread(pos.getX() >> 4,pos.getZ() >> 4, ((ServerLevel) level)) : got; //Skip it if we got the current world data
-    }
-
-    @Nullable
-    public RegionizedWorldData getDataAnyThread(@NotNull Level level, int x,int z){
-        final RegionizedWorldData got = level.getCurrentWorldDataUnsafe();
-        return got == null ? getDataOffTickThread(x >> 4,z >> 4, ((ServerLevel) level)) : got; //Skip it if we got the current world data
-    }
-
-    @Nullable
-    public RegionizedWorldData getDataAnyThread(int chunkX,int chunkZ,Level level){
-        final RegionizedWorldData got = level.getCurrentWorldDataUnsafe();
-        return got == null ? getDataOffTickThread(chunkX,chunkZ, ((ServerLevel) level)) : got; //Skip it if we got the current world data
-    }
-
-
-    @Nullable
-    public RegionizedWorldData getDataAnyThread(@NotNull Location loc){
-        final RegionizedWorldData got = ((CraftWorld) loc.getWorld()).getHandle().getCurrentWorldDataUnsafe();
-        return got == null ? getDataOffTickThread(loc.blockX() >> 4,loc.blockZ() >> 4, ((CraftWorld) loc.getWorld()).getHandle()) : got; //Skip it if we got the current world data
-    }
-
-    @Nullable
-    public RegionizedWorldData getDataOffTickThread(int chunkX,int chunkZ,@NotNull ServerLevel level){
-        ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> target = level.regioniser.getRegionAtUnsynchronised(chunkX,chunkZ);
-        RegionizedWorldData ret;
-
-        if ((target != null) && target.getData() != null && (ret = target.getData().getRegionizedData(target.regioniser.world.worldRegionData)) != null){
-            return ret;
-        }
-
-        return null; //TODO Fast-fail?
-    }
-}
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 25a2f23618cd02366f71e704638adfbaed9fa8c5..62fe8ca9e71d5ad6ca42b2a2b23e99168eef4449 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -2035,7 +2036,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
             List<PathNavigation> list = new ObjectArrayList();
-            Iterator iterator = this.getCurrentWorldData().getNavigatingMobs(); // Folia - region threading
+            Iterator iterator = this.getCurrentWorldData().getNavigatingMobs().iterator(); // Folia - region threading
 
             while (iterator.hasNext()) {
                 // CraftBukkit start - fix SPIGOT-6362
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index a9921af214c596ef2601ccdbf37b4234bcf4ea1d..9f9655f4ffd4bdc4abc793fe694df3935ecd30f6 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -10,6 +10,9 @@ import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+import me.earthme.lightingluminol.RegonizedWorldDataSwitcher;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -214,16 +217,19 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     );
     public volatile io.papermc.paper.threadedregions.RegionizedServer.WorldLevelData tickData;
     public final java.util.concurrent.ConcurrentHashMap.KeySetView<net.minecraft.server.level.ChunkHolder, Boolean> needsChangeBroadcasting = java.util.concurrent.ConcurrentHashMap.newKeySet();
+    public final RegonizedWorldDataSwitcher dataSwitcher = new RegonizedWorldDataSwitcher();
 
     public io.papermc.paper.threadedregions.RegionizedWorldData getCurrentWorldData() {
         final io.papermc.paper.threadedregions.RegionizedWorldData ret = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData();
         if (ret == null) {
-            return ret;
+            return this.dataSwitcher.getLastMatch();
         }
         Level world = ret.world;
         if (world != this) {
-            throw new IllegalStateException("World mismatch: expected " + this.getWorld().getName() + " but got " + world.getWorld().getName());
+            //throw new IllegalStateException("World mismatch: expected " + this.getWorld().getName() + " but got " + world.getWorld().getName());
+            return this.dataSwitcher.getLastMatch();
         }
+        this.dataSwitcher.updateCurrent(ret);
         return ret;
     }
 
